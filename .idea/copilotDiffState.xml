<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/modules/intent_classifier.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/modules/intent_classifier.py" />
              <option name="originalContent" value="import re&#10;import os&#10;from enum import Enum&#10;from typing import Dict, Tuple, Optional, List&#10;from google import genai&#10;from dotenv import load_dotenv&#10;&#10;&#10;class Intent(Enum):&#10;    &quot;&quot;&quot;Enumeration of all possible user intents&quot;&quot;&quot;&#10;    NAV_NEXT = &quot;nav_next&quot;&#10;    NAV_PREV = &quot;nav_prev&quot;&#10;    NAV_GO_TO = &quot;nav_go_to&quot;&#10;    NAV_REPEAT = &quot;nav_repeat&quot;&#10;    NAV_START = &quot;nav_start&quot;&#10;    QUESTION = &quot;question&quot;&#10;    SEARCH_RECIPE = &quot;search_recipe&quot;&#10;    START_RECIPE = &quot;start_recipe&quot;&#10;    STOP_PAUSE = &quot;stop_pause&quot;&#10;    RESUME = &quot;resume&quot;&#10;    CONFIRM = &quot;confirm&quot;&#10;    CANCEL = &quot;cancel&quot;&#10;    SMALL_TALK = &quot;small_talk&quot;&#10;    CLARIFY = &quot;clarify&quot;&#10;    HELP = &quot;help&quot;&#10;    UNKNOWN = &quot;unknown&quot;&#10;&#10;&#10;class IntentClassifier:&#10;    &quot;&quot;&quot;&#10;    Hybrid Intent Classifier using rule-based patterns with LLM fallback&#10;&#10;    Strategy:&#10;    1. Try rule-based classification with confidence score&#10;    2. If confidence &lt; threshold, use LLM for classification&#10;    3. Return intent + confidence + extracted entities&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, confidence_threshold=0.7, use_llm_fallback=True):&#10;        &quot;&quot;&quot;&#10;        Initialize the Intent Classifier&#10;&#10;        Args:&#10;            confidence_threshold (float): Minimum confidence for rule-based classification&#10;            use_llm_fallback (bool): Whether to use LLM when rule-based confidence is low&#10;        &quot;&quot;&quot;&#10;        load_dotenv()&#10;&#10;        self.confidence_threshold = confidence_threshold&#10;        self.use_llm_fallback = use_llm_fallback&#10;&#10;        # Initialize Gemini client for LLM fallback&#10;        if use_llm_fallback:&#10;            api_key = os.getenv(&quot;Gemini_API_key&quot;)&#10;            if api_key:&#10;                self.client = genai.Client(api_key=api_key)&#10;                self.model_name = &quot;gemini-2.5-flash&quot;&#10;                print(&quot;Intent Classifier initialized with LLM fallback&quot;)&#10;            else:&#10;                print(&quot;Warning: Gemini API key not found. LLM fallback disabled.&quot;)&#10;                self.use_llm_fallback = False&#10;&#10;        # Define rule-based patterns for each intent&#10;        self.intent_patterns = self._initialize_patterns()&#10;&#10;    def _initialize_patterns(self) -&gt; Dict[Intent, List[Dict]]:&#10;        &quot;&quot;&quot;&#10;        Initialize regex patterns and keywords for rule-based classification&#10;&#10;        Returns:&#10;            Dictionary mapping intents to their patterns and keywords&#10;        &quot;&quot;&quot;&#10;        return {&#10;            Intent.NAV_NEXT: [&#10;                {&quot;pattern&quot;: r&quot;\b(next|continue|forward|proceed|go ahead|move on)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(what'?s next|after that|then what)\b&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(skip|move forward)\b&quot;, &quot;confidence&quot;: 0.85},&#10;            ],&#10;            Intent.NAV_PREV: [&#10;                {&quot;pattern&quot;: r&quot;\b(previous|back|before|earlier|go back|last step)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(what was (that|the last)|can you repeat|say that again)\b&quot;, &quot;confidence&quot;: 0.85},&#10;                {&quot;pattern&quot;: r&quot;\b(undo|rewind)\b&quot;, &quot;confidence&quot;: 0.8},&#10;            ],&#10;            Intent.NAV_GO_TO: [&#10;                {&quot;pattern&quot;: r&quot;\b(go to|jump to|skip to) (step|ingredient)?\s*(\d+|first|last|beginning|end)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(step|ingredient)?\s*(\d+|first|last)\b&quot;, &quot;confidence&quot;: 0.7},&#10;            ],&#10;            Intent.NAV_START: [&#10;                {&quot;pattern&quot;: r&quot;\b(repeat|start|begin).*(from )?(the )?(beginning|start|top|starting)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(start|begin|let'?s (start|begin|go)|show me how)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(from the (beginning|start|top)|take me through)\b&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(restart|start over|begin again)\b&quot;, &quot;confidence&quot;: 0.95},&#10;            ],&#10;            Intent.NAV_REPEAT: [&#10;                {&quot;pattern&quot;: r&quot;\b(repeat|say (that|it) again|one more time|again|pardon)(?!.*(beginning|start|top|starting))\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(what did you say|didn'?t (catch|hear) that)\b&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(come again|excuse me)\b&quot;, &quot;confidence&quot;: 0.75},&#10;            ],&#10;            Intent.SMALL_TALK: [&#10;                {&quot;pattern&quot;: r&quot;\b(hi|hello|hey|good (morning|afternoon|evening)|greetings)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(how are you|how'?re you|how are u|how r u|how'?s it going|what'?s up)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(thanks|thank you|bye|goodbye|see you|take care)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(nice|great|awesome|cool|good job|well done)\b$&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(weather|how'?s your day|doing today|feeling)\b&quot;, &quot;confidence&quot;: 0.85},&#10;            ],&#10;            Intent.QUESTION: [&#10;                {&quot;pattern&quot;: r&quot;\b(substitute|replace|alternative|instead of|swap)\b&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(how much|how many|how long|what temperature|what time)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(why|when|where|which)\b.*(step|ingredient|recipe|cook|add|mix|heat)\b&quot;, &quot;confidence&quot;: 0.85},&#10;                {&quot;pattern&quot;: r&quot;\b(what|how).*(temperature|time|long|much|many|ingredient|substitute)\b&quot;, &quot;confidence&quot;: 0.85},&#10;                {&quot;pattern&quot;: r&quot;\b(can i|could i|should i|is it okay).*(use|add|replace|skip)\b&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(tell me (about|more)|explain|describe).*(recipe|step|ingredient|process)\b&quot;, &quot;confidence&quot;: 0.85},&#10;            ],&#10;            Intent.SEARCH_RECIPE: [&#10;                {&quot;pattern&quot;: r&quot;\b(find|search|look for|show me|give me|i want|i need) (a |some |the )?(recipe|dish)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(how (do|to) (make|cook|prepare)|recipe for)\b&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(cook|make|prepare)\s+\w+&quot;, &quot;confidence&quot;: 0.7},&#10;            ],&#10;            Intent.START_RECIPE: [&#10;                {&quot;pattern&quot;: r&quot;\b(start|begin|let'?s (do|make|cook)) (this|that|it|the recipe)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(okay let'?s go|let'?s start cooking|ready to cook)\b&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(show me (the |how to )?steps|walk me through)\b&quot;, &quot;confidence&quot;: 0.85},&#10;            ],&#10;            Intent.STOP_PAUSE: [&#10;                {&quot;pattern&quot;: r&quot;\b(stop|pause|wait|hold on|hang on)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(just a (second|minute|moment)|give me a (second|minute))\b&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(cancel|never mind|stop reading)\b&quot;, &quot;confidence&quot;: 0.85},&#10;            ],&#10;            Intent.RESUME: [&#10;                {&quot;pattern&quot;: r&quot;\b(resume|continue|go on|keep going|carry on)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(okay (continue|go ahead)|i'?m back|ready now)\b&quot;, &quot;confidence&quot;: 0.9},&#10;            ],&#10;            Intent.CONFIRM: [&#10;                {&quot;pattern&quot;: r&quot;\b(yes|yeah|yep|sure|okay|ok|alright|correct|right|exactly)\b$&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(that'?s (right|correct)|sounds good|go ahead)\b&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(affirmative|indeed|absolutely)\b&quot;, &quot;confidence&quot;: 0.85},&#10;            ],&#10;            Intent.CANCEL: [&#10;                {&quot;pattern&quot;: r&quot;\b(no|nope|nah|cancel|stop|don'?t|never mind)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(not (really|now)|maybe later|skip (it|this))\b&quot;, &quot;confidence&quot;: 0.85},&#10;            ],&#10;            Intent.HELP: [&#10;                {&quot;pattern&quot;: r&quot;\b(help|assist|support|what can you do|commands)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(how (do|does) (this|it) work|instructions|guide)\b&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(i'?m (lost|confused|stuck)|don'?t understand)\b&quot;, &quot;confidence&quot;: 0.85},&#10;            ],&#10;        }&#10;&#10;    def classify(self, user_input: str, context: Optional[Dict] = None) -&gt; Tuple[Intent, float, Dict]:&#10;        &quot;&quot;&quot;&#10;        Classify user intent using hybrid approach&#10;&#10;        Args:&#10;            user_input (str): The user's spoken/text input&#10;            context (dict, optional): Session context for better classification&#10;&#10;        Returns:&#10;            Tuple of (Intent, confidence_score, extracted_entities)&#10;        &quot;&quot;&quot;&#10;        if not user_input or not user_input.strip():&#10;            return Intent.UNKNOWN, 0.0, {}&#10;&#10;        # Normalize input&#10;        normalized_input = user_input.lower().strip()&#10;&#10;        # Step 1: Try rule-based classification&#10;        intent, confidence, entities = self._rule_based_classify(normalized_input, context)&#10;&#10;        print(f&quot;Rule-based: Intent={intent.value}, Confidence={confidence:.2f}&quot;)&#10;&#10;        # Step 2: Use LLM fallback if confidence is low&#10;        if confidence &lt; self.confidence_threshold and self.use_llm_fallback:&#10;            print(f&quot;Confidence below threshold ({self.confidence_threshold}), using LLM fallback...&quot;)&#10;            llm_intent, llm_confidence, llm_entities = self._llm_classify(user_input, context)&#10;&#10;            # Use LLM result if it has higher confidence&#10;            if llm_confidence &gt; confidence:&#10;                print(f&quot;LLM: Intent={llm_intent.value}, Confidence={llm_confidence:.2f} (selected)&quot;)&#10;                return llm_intent, llm_confidence, llm_entities&#10;            else:&#10;                print(f&quot;LLM: Intent={llm_intent.value}, Confidence={llm_confidence:.2f} (rule-based kept)&quot;)&#10;&#10;        return intent, confidence, entities&#10;&#10;    def _rule_based_classify(self, normalized_input: str, context: Optional[Dict]) -&gt; Tuple[Intent, float, Dict]:&#10;        &quot;&quot;&quot;&#10;        Perform rule-based classification using regex patterns&#10;&#10;        Args:&#10;            normalized_input (str): Normalized user input&#10;            context (dict, optional): Session context&#10;&#10;        Returns:&#10;            Tuple of (Intent, confidence_score, extracted_entities)&#10;        &quot;&quot;&quot;&#10;        best_match = (Intent.UNKNOWN, 0.0, {})&#10;&#10;        # Check each intent's patterns&#10;        for intent, patterns in self.intent_patterns.items():&#10;            for pattern_dict in patterns:&#10;                pattern = pattern_dict[&quot;pattern&quot;]&#10;                base_confidence = pattern_dict[&quot;confidence&quot;]&#10;&#10;                match = re.search(pattern, normalized_input, re.IGNORECASE)&#10;                if match:&#10;                    # Extract entities based on intent type&#10;                    entities = self._extract_entities(intent, match, normalized_input)&#10;&#10;                    # Apply context boosting&#10;                    adjusted_confidence = self._apply_context_boost(&#10;                        intent, base_confidence, context, entities&#10;                    )&#10;&#10;                    # Keep best match&#10;                    if adjusted_confidence &gt; best_match[1]:&#10;                        best_match = (intent, adjusted_confidence, entities)&#10;&#10;        return best_match&#10;&#10;    def _extract_entities(self, intent: Intent, match: re.Match, text: str) -&gt; Dict:&#10;        &quot;&quot;&quot;&#10;        Extract relevant entities based on intent type&#10;&#10;        Args:&#10;            intent (Intent): Detected intent&#10;            match (re.Match): Regex match object&#10;            text (str): Full input text&#10;&#10;        Returns:&#10;            Dictionary of extracted entities&#10;        &quot;&quot;&quot;&#10;        entities = {}&#10;&#10;        # Extract step numbers for navigation&#10;        if intent in [Intent.NAV_GO_TO]:&#10;            step_match = re.search(r'\b(\d+)\b', text)&#10;            if step_match:&#10;                entities[&quot;step_number&quot;] = int(step_match.group(1))&#10;            elif &quot;first&quot; in text or &quot;beginning&quot; in text or &quot;start&quot; in text:&#10;                entities[&quot;step_number&quot;] = 1&#10;                entities[&quot;position&quot;] = &quot;first&quot;&#10;            elif &quot;last&quot; in text or &quot;end&quot; in text:&#10;                entities[&quot;position&quot;] = &quot;last&quot;&#10;&#10;        # Extract recipe name for search&#10;        if intent == Intent.SEARCH_RECIPE:&#10;            # Try to extract recipe name after trigger words&#10;            recipe_patterns = [&#10;                r'(?:recipe for|make|cook|prepare|find|search for|show me)\s+(?:a |an |the |some )?(.+?)(?:\?|$)',&#10;                r'(?:how to make|how to cook|how to prepare)\s+(?:a |an |the |some )?(.+?)(?:\?|$)',&#10;            ]&#10;            for pattern in recipe_patterns:&#10;                recipe_match = re.search(pattern, text, re.IGNORECASE)&#10;                if recipe_match:&#10;                    entities[&quot;recipe_name&quot;] = recipe_match.group(1).strip()&#10;                    break&#10;&#10;        # Extract question content&#10;        if intent == Intent.QUESTION:&#10;            entities[&quot;question_text&quot;] = text&#10;            # Identify question type&#10;            if re.search(r'\b(substitute|replace|instead of|alternative)\b', text):&#10;                entities[&quot;question_type&quot;] = &quot;substitution&quot;&#10;            elif re.search(r'\b(how long|how much time|duration)\b', text):&#10;                entities[&quot;question_type&quot;] = &quot;timing&quot;&#10;            elif re.search(r'\b(how much|how many|quantity)\b', text):&#10;                entities[&quot;question_type&quot;] = &quot;quantity&quot;&#10;            elif re.search(r'\b(what temperature|how hot)\b', text):&#10;                entities[&quot;question_type&quot;] = &quot;temperature&quot;&#10;            else:&#10;                entities[&quot;question_type&quot;] = &quot;general&quot;&#10;&#10;        return entities&#10;&#10;    def _apply_context_boost(self, intent: Intent, base_confidence: float,&#10;                            context: Optional[Dict], entities: Dict) -&gt; float:&#10;        &quot;&quot;&quot;&#10;        Adjust confidence based on session context&#10;&#10;        Args:&#10;            intent (Intent): Detected intent&#10;            base_confidence (float): Base confidence from pattern matching&#10;            context (dict, optional): Session context&#10;            entities (dict): Extracted entities&#10;&#10;        Returns:&#10;            Adjusted confidence score&#10;        &quot;&quot;&quot;&#10;        if not context:&#10;            return base_confidence&#10;&#10;        confidence = base_confidence&#10;        current_state = context.get(&quot;current_state&quot;, &quot;IDLE&quot;)&#10;&#10;        # Boost navigation intents when in active recipe&#10;        if intent in [Intent.NAV_NEXT, Intent.NAV_PREV, Intent.NAV_REPEAT, Intent.NAV_GO_TO]:&#10;            if current_state in [&quot;READING_INGREDIENTS&quot;, &quot;READING_STEPS&quot;, &quot;RECIPE_ACTIVE&quot;]:&#10;                confidence = min(1.0, confidence + 0.1)&#10;&#10;        # Boost START_RECIPE when recipe is selected&#10;        if intent == Intent.START_RECIPE:&#10;            if current_state == &quot;RECIPE_SELECTED&quot;:&#10;                confidence = min(1.0, confidence + 0.15)&#10;&#10;        # Boost RESUME when paused&#10;        if intent == Intent.RESUME:&#10;            if context.get(&quot;paused&quot;) == &quot;true&quot; or current_state == &quot;PAUSED&quot;:&#10;                confidence = min(1.0, confidence + 0.15)&#10;&#10;        # Boost QUESTION when in active recipe&#10;        if intent == Intent.QUESTION:&#10;            if current_state in [&quot;READING_INGREDIENTS&quot;, &quot;READING_STEPS&quot;, &quot;RECIPE_ACTIVE&quot;]:&#10;                confidence = min(1.0, confidence + 0.05)&#10;&#10;        return confidence&#10;&#10;    def _llm_classify(self, user_input: str, context: Optional[Dict]) -&gt; Tuple[Intent, float, Dict]:&#10;        &quot;&quot;&quot;&#10;        Use LLM to classify ambiguous intents&#10;&#10;        Args:&#10;            user_input (str): The user's input&#10;            context (dict, optional): Session context&#10;&#10;        Returns:&#10;            Tuple of (Intent, confidence_score, extracted_entities)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Build context string&#10;            context_str = &quot;&quot;&#10;            if context:&#10;                context_str = f&quot;&quot;&quot;&#10;Current Session Context:&#10;- State: {context.get('current_state', 'IDLE')}&#10;- Recipe Active: {context.get('recipe_id', 'None')}&#10;- Current Section: {context.get('current_section', 'None')}&#10;- Paused: {context.get('paused', 'false')}&#10;&quot;&quot;&quot;&#10;&#10;            # Create prompt for LLM&#10;            prompt = f&quot;&quot;&quot;You are an intent classifier for a conversational recipe voice assistant. &#10;Classify the user's input into ONE of the following intents:&#10;&#10;Available Intents:&#10;- nav_next: User wants to go to the next step/ingredient&#10;- nav_prev: User wants to go back to previous step/ingredient&#10;- nav_go_to: User wants to jump to a specific step/ingredient&#10;- nav_repeat: User wants to hear the current step again&#10;- nav_start: User wants to start from the beginning&#10;- question: User is asking a question about the recipe&#10;- search_recipe: User wants to find/search for a recipe&#10;- start_recipe: User wants to start cooking a selected recipe&#10;- stop_pause: User wants to pause or stop&#10;- resume: User wants to resume after pausing&#10;- confirm: User is confirming/agreeing (yes, okay, etc.)&#10;- cancel: User is canceling/disagreeing (no, cancel, etc.)&#10;- small_talk: Greetings or casual conversation or weather info &#10;- clarify: User needs clarification&#10;- help: User needs help or instructions&#10;- unknown: Cannot determine intent&#10;&#10;{context_str}&#10;&#10;User Input: &quot;{user_input}&quot;&#10;&#10;Respond in JSON format:&#10;{{&#10;    &quot;intent&quot;: &quot;intent_name&quot;,&#10;    &quot;confidence&quot;: 0.0-1.0,&#10;    &quot;reasoning&quot;: &quot;brief explanation&quot;,&#10;    &quot;entities&quot;: {{}}&#10;}}&#10;&#10;Extract relevant entities (e.g., step numbers, recipe names, question text) in the entities field.&#10;&quot;&quot;&quot;&#10;&#10;            # Call Gemini API&#10;            response = self.client.models.generate_content(&#10;                model=self.model_name,&#10;                contents=prompt&#10;            )&#10;&#10;            # Parse response&#10;            response_text = response.text.strip()&#10;            print(f&quot;LLM Response: {response_text}&quot;)&#10;&#10;            # Extract JSON from response (handle markdown code blocks)&#10;            if &quot;```json&quot; in response_text:&#10;                json_start = response_text.find(&quot;```json&quot;) + 7&#10;                json_end = response_text.find(&quot;```&quot;, json_start)&#10;                response_text = response_text[json_start:json_end].strip()&#10;            elif &quot;```&quot; in response_text:&#10;                json_start = response_text.find(&quot;```&quot;) + 3&#10;                json_end = response_text.find(&quot;```&quot;, json_start)&#10;                response_text = response_text[json_start:json_end].strip()&#10;&#10;            import json&#10;            result = json.loads(response_text)&#10;&#10;            # Map string intent to Intent enum&#10;            intent_str = result.get(&quot;intent&quot;, &quot;unknown&quot;)&#10;            try:&#10;                intent = Intent(intent_str)&#10;            except ValueError:&#10;                intent = Intent.UNKNOWN&#10;&#10;            confidence = float(result.get(&quot;confidence&quot;, 0.5))&#10;            entities = result.get(&quot;entities&quot;, {})&#10;&#10;            return intent, confidence, entities&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error in LLM classification: {str(e)}&quot;)&#10;            return Intent.UNKNOWN, 0.3, {}&#10;&#10;    def get_intent_description(self, intent: Intent) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Get human-readable description of an intent&#10;&#10;        Args:&#10;            intent (Intent): The intent to describe&#10;&#10;        Returns:&#10;            Description string&#10;        &quot;&quot;&quot;&#10;        descriptions = {&#10;            Intent.NAV_NEXT: &quot;Navigate to next step/ingredient&quot;,&#10;            Intent.NAV_PREV: &quot;Navigate to previous step/ingredient&quot;,&#10;            Intent.NAV_GO_TO: &quot;Jump to specific step/ingredient&quot;,&#10;            Intent.NAV_REPEAT: &quot;Repeat current step&quot;,&#10;            Intent.NAV_START: &quot;Start from beginning&quot;,&#10;            Intent.QUESTION: &quot;Ask a question about the recipe&quot;,&#10;            Intent.SEARCH_RECIPE: &quot;Search for a recipe&quot;,&#10;            Intent.START_RECIPE: &quot;Begin cooking selected recipe&quot;,&#10;            Intent.STOP_PAUSE: &quot;Pause or stop&quot;,&#10;            Intent.RESUME: &quot;Resume from pause&quot;,&#10;            Intent.CONFIRM: &quot;Confirm/agree&quot;,&#10;            Intent.CANCEL: &quot;Cancel/disagree&quot;,&#10;            Intent.SMALL_TALK: &quot;Casual conversation&quot;,&#10;            Intent.CLARIFY: &quot;Request clarification&quot;,&#10;            Intent.HELP: &quot;Request help&quot;,&#10;            Intent.UNKNOWN: &quot;Cannot determine intent&quot;&#10;        }&#10;        return descriptions.get(intent, &quot;Unknown intent&quot;)&#10;&#10;&#10;# Test function&#10;def test_intent_classifier():&#10;    &quot;&quot;&quot;Test the intent classifier with sample inputs&quot;&quot;&quot;&#10;    classifier = IntentClassifier(confidence_threshold=0.7, use_llm_fallback=True)&#10;&#10;    test_cases = [&#10;        (&quot;next step please&quot;, None),&#10;        (&quot;go back&quot;, None),&#10;        (&quot;what's the third step?&quot;, {&quot;current_state&quot;: &quot;RECIPE_ACTIVE&quot;}),&#10;        (&quot;repeat that&quot;, {&quot;current_state&quot;: &quot;READING_STEPS&quot;}),&#10;        (&quot;how do I make pasta?&quot;, None),&#10;        (&quot;start cooking&quot;, {&quot;current_state&quot;: &quot;RECIPE_SELECTED&quot;}),&#10;        (&quot;pause&quot;, None),&#10;        (&quot;can I use butter instead of oil?&quot;, {&quot;current_state&quot;: &quot;RECIPE_ACTIVE&quot;}),&#10;        (&quot;yes&quot;, None),&#10;        (&quot;what is weather today&quot;, None),&#10;        (&quot;Can u repeat the recipe from starting?&quot;, None),&#10;        (&quot;well how are u doing today?&quot;, None),&#10;        (&quot;find me a recipe for chocolate cake&quot;, None),&#10;        (&quot;let's start cooking this recipe&quot;, {&quot;current_state&quot;: &quot;RECIPE_SELECTED&quot;}),&#10;        (&quot;resume where we left off&quot;, {&quot;current_state&quot;: &quot;PAUSED&quot;}),&#10;        (&quot;no, I don't want that&quot;, None),&#10;        (&quot;help me with the commands&quot;, None),&#10;        (&quot;&quot;, None),&#10;        (&quot;   &quot;, None),&#10;        (&quot;blablabla unknown input&quot;, None),&#10;        (&quot;how to make a vegan salad?&quot;, None),&#10;    ]&#10;&#10;    print(&quot;=&quot; * 60)&#10;    print(&quot;INTENT CLASSIFIER TEST&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;    for user_input, context in test_cases:&#10;        print(f&quot;\nInput: '{user_input}'&quot;)&#10;        if context:&#10;            print(f&quot;Context: {context}&quot;)&#10;&#10;        intent, confidence, entities = classifier.classify(user_input, context)&#10;&#10;        print(f&quot;→ Intent: {intent.value}&quot;)&#10;        print(f&quot;→ Confidence: {confidence:.2f}&quot;)&#10;        print(f&quot;→ Description: {classifier.get_intent_description(intent)}&quot;)&#10;        if entities:&#10;            print(f&quot;→ Entities: {entities}&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    test_intent_classifier()&#10;&#10;" />
              <option name="updatedContent" value="import re&#10;import os&#10;from enum import Enum&#10;from typing import Dict, Tuple, Optional, List&#10;from google import genai&#10;from dotenv import load_dotenv&#10;&#10;&#10;class Intent(Enum):&#10;    &quot;&quot;&quot;Enumeration of all possible user intents&quot;&quot;&quot;&#10;    NAV_NEXT = &quot;nav_next&quot;&#10;    NAV_PREV = &quot;nav_prev&quot;&#10;    NAV_GO_TO = &quot;nav_go_to&quot;&#10;    NAV_REPEAT = &quot;nav_repeat&quot;&#10;    NAV_START = &quot;nav_start&quot;&#10;    QUESTION = &quot;question&quot;&#10;    SEARCH_RECIPE = &quot;search_recipe&quot;&#10;    START_RECIPE = &quot;start_recipe&quot;&#10;    STOP_PAUSE = &quot;stop_pause&quot;&#10;    RESUME = &quot;resume&quot;&#10;    CONFIRM = &quot;confirm&quot;&#10;    CANCEL = &quot;cancel&quot;&#10;    SMALL_TALK = &quot;small_talk&quot;&#10;    CLARIFY = &quot;clarify&quot;&#10;    HELP = &quot;help&quot;&#10;    UNKNOWN = &quot;unknown&quot;&#10;&#10;&#10;class IntentClassifier:&#10;    &quot;&quot;&quot;&#10;    Hybrid Intent Classifier using rule-based patterns with LLM fallback&#10;&#10;    Strategy:&#10;    1. Try rule-based classification with confidence score&#10;    2. If confidence &lt; threshold, use LLM for classification&#10;    3. Return intent + confidence + extracted entities&#10;    &quot;&quot;&quot;&#10;&#10;    # Confidence constants for pattern matching&#10;    CONFIDENCE_VERY_HIGH = 0.95&#10;    CONFIDENCE_HIGH = 0.90&#10;    CONFIDENCE_MEDIUM_HIGH = 0.85&#10;    CONFIDENCE_MEDIUM = 0.80&#10;    CONFIDENCE_MEDIUM_LOW = 0.75&#10;    CONFIDENCE_LOW = 0.70&#10;    &#10;    # Confidence boosts for context&#10;    CONTEXT_BOOST_SMALL = 0.05&#10;    CONTEXT_BOOST_MEDIUM = 0.10&#10;    CONTEXT_BOOST_LARGE = 0.15&#10;    &#10;    # LLM fallback confidence defaults&#10;    LLM_DEFAULT_CONFIDENCE = 0.50&#10;    LLM_ERROR_CONFIDENCE = 0.30&#10;&#10;    def __init__(self, confidence_threshold=0.7, use_llm_fallback=True):&#10;        &quot;&quot;&quot;&#10;        Initialize the Intent Classifier&#10;&#10;        Args:&#10;            confidence_threshold (float): Minimum confidence for rule-based classification&#10;            use_llm_fallback (bool): Whether to use LLM when rule-based confidence is low&#10;        &quot;&quot;&quot;&#10;        load_dotenv()&#10;&#10;        self.confidence_threshold = confidence_threshold&#10;        self.use_llm_fallback = use_llm_fallback&#10;&#10;        # Initialize Gemini client for LLM fallback&#10;        if use_llm_fallback:&#10;            api_key = os.getenv(&quot;Gemini_API_key&quot;)&#10;            if api_key:&#10;                self.client = genai.Client(api_key=api_key)&#10;                self.model_name = &quot;gemini-2.5-flash&quot;&#10;                print(&quot;Intent Classifier initialized with LLM fallback&quot;)&#10;            else:&#10;                print(&quot;Warning: Gemini API key not found. LLM fallback disabled.&quot;)&#10;                self.use_llm_fallback = False&#10;&#10;        # Define rule-based patterns for each intent&#10;        self.intent_patterns = self._initialize_patterns()&#10;&#10;    def _initialize_patterns(self) -&gt; Dict[Intent, List[Dict]]:&#10;        &quot;&quot;&quot;&#10;        Initialize regex patterns and keywords for rule-based classification&#10;&#10;        Returns:&#10;            Dictionary mapping intents to their patterns and keywords&#10;        &quot;&quot;&quot;&#10;        return {&#10;            Intent.NAV_NEXT: [&#10;                {&quot;pattern&quot;: r&quot;\b(next|continue|forward|proceed|go ahead|move on)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(what'?s next|after that|then what)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(skip|move forward)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_MEDIUM_HIGH},&#10;            ],&#10;            Intent.NAV_PREV: [&#10;                {&quot;pattern&quot;: r&quot;\b(previous|back|before|earlier|go back|last step)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(what was (that|the last)|can you repeat|say that again)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_MEDIUM_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(undo|rewind)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_MEDIUM},&#10;            ],&#10;            Intent.NAV_GO_TO: [&#10;                {&quot;pattern&quot;: r&quot;\b(go to|jump to|skip to) (step|ingredient)?\s*(\d+|first|last|beginning|end)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(step|ingredient)?\s*(\d+|first|last)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_LOW},&#10;            ],&#10;            Intent.NAV_START: [&#10;                {&quot;pattern&quot;: r&quot;\b(repeat|start|begin).*(from )?(the )?(beginning|start|top|starting)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(start|begin|let'?s (start|begin|go)|show me how)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(from the (beginning|start|top)|take me through)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(restart|start over|begin again)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;            ],&#10;            Intent.NAV_REPEAT: [&#10;                {&quot;pattern&quot;: r&quot;\b(repeat|say (that|it) again|one more time|again|pardon)(?!.*(beginning|start|top|starting))\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(what did you say|didn'?t (catch|hear) that)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(come again|excuse me)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_MEDIUM_LOW},&#10;            ],&#10;            Intent.SMALL_TALK: [&#10;                {&quot;pattern&quot;: r&quot;\b(hi|hello|hey|good (morning|afternoon|evening)|greetings)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(how are you|how'?re you|how are u|how r u|how'?s it going|what'?s up)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(thanks|thank you|bye|goodbye|see you|take care)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(nice|great|awesome|cool|good job|well done)\b$&quot;, &quot;confidence&quot;: self.CONFIDENCE_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(weather|how'?s your day|doing today|feeling)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_MEDIUM_HIGH},&#10;            ],&#10;            Intent.QUESTION: [&#10;                {&quot;pattern&quot;: r&quot;\b(substitute|replace|alternative|instead of|swap)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(how much|how many|how long|what temperature|what time)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(why|when|where|which)\b.*(step|ingredient|recipe|cook|add|mix|heat)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_MEDIUM_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(what|how).*(temperature|time|long|much|many|ingredient|substitute)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_MEDIUM_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(can i|could i|should i|is it okay).*(use|add|replace|skip)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(tell me (about|more)|explain|describe).*(recipe|step|ingredient|process)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_MEDIUM_HIGH},&#10;            ],&#10;            Intent.SEARCH_RECIPE: [&#10;                {&quot;pattern&quot;: r&quot;\b(find|search|look for|show me|give me|i want|i need) (a |some |the )?(recipe|dish)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(how (do|to) (make|cook|prepare)|recipe for)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(cook|make|prepare)\s+\w+&quot;, &quot;confidence&quot;: self.CONFIDENCE_LOW},&#10;            ],&#10;            Intent.START_RECIPE: [&#10;                {&quot;pattern&quot;: r&quot;\b(start|begin|let'?s (do|make|cook)) (this|that|it|the recipe)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(okay let'?s go|let'?s start cooking|ready to cook)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(show me (the |how to )?steps|walk me through)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_MEDIUM_HIGH},&#10;            ],&#10;            Intent.STOP_PAUSE: [&#10;                {&quot;pattern&quot;: r&quot;\b(stop|pause|wait|hold on|hang on)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(just a (second|minute|moment)|give me a (second|minute))\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(cancel|never mind|stop reading)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_MEDIUM_HIGH},&#10;            ],&#10;            Intent.RESUME: [&#10;                {&quot;pattern&quot;: r&quot;\b(resume|continue|go on|keep going|carry on)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(okay (continue|go ahead)|i'?m back|ready now)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_HIGH},&#10;            ],&#10;            Intent.CONFIRM: [&#10;                {&quot;pattern&quot;: r&quot;\b(yes|yeah|yep|sure|okay|ok|alright|correct|right|exactly)\b$&quot;, &quot;confidence&quot;: self.CONFIDENCE_VERY_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(that'?s (right|correct)|sounds good|go ahead)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_HIGH},&#10;                {&quot;pattern&quot;: r&quot;\b(affirmative|indeed|absolutely)\b&quot;, &quot;confidence&quot;: self.CONFIDENCE_MEDIUM_HIGH},&#10;            ],&#10;            Intent.CANCEL: [&#10;                {&quot;pattern&quot;: r&quot;\b(no|nope|nah|cancel|stop|don'?t|never mind)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(not (really|now)|maybe later|skip (it|this))\b&quot;, &quot;confidence&quot;: 0.85},&#10;            ],&#10;            Intent.HELP: [&#10;                {&quot;pattern&quot;: r&quot;\b(help|assist|support|what can you do|commands)\b&quot;, &quot;confidence&quot;: 0.95},&#10;                {&quot;pattern&quot;: r&quot;\b(how (do|does) (this|it) work|instructions|guide)\b&quot;, &quot;confidence&quot;: 0.9},&#10;                {&quot;pattern&quot;: r&quot;\b(i'?m (lost|confused|stuck)|don'?t understand)\b&quot;, &quot;confidence&quot;: 0.85},&#10;            ],&#10;        }&#10;&#10;    def classify(self, user_input: str, context: Optional[Dict] = None) -&gt; Tuple[Intent, float, Dict]:&#10;        &quot;&quot;&quot;&#10;        Classify user intent using hybrid approach&#10;&#10;        Args:&#10;            user_input (str): The user's spoken/text input&#10;            context (dict, optional): Session context for better classification&#10;&#10;        Returns:&#10;            Tuple of (Intent, confidence_score, extracted_entities)&#10;        &quot;&quot;&quot;&#10;        if not user_input or not user_input.strip():&#10;            return Intent.UNKNOWN, 0.0, {}&#10;&#10;        # Normalize input&#10;        normalized_input = user_input.lower().strip()&#10;&#10;        # Step 1: Try rule-based classification&#10;        intent, confidence, entities = self._rule_based_classify(normalized_input, context)&#10;&#10;        print(f&quot;Rule-based: Intent={intent.value}, Confidence={confidence:.2f}&quot;)&#10;&#10;        # Step 2: Use LLM fallback if confidence is low&#10;        if confidence &lt; self.confidence_threshold and self.use_llm_fallback:&#10;            print(f&quot;Confidence below threshold ({self.confidence_threshold}), using LLM fallback...&quot;)&#10;            llm_intent, llm_confidence, llm_entities = self._llm_classify(user_input, context)&#10;&#10;            # Use LLM result if it has higher confidence&#10;            if llm_confidence &gt; confidence:&#10;                print(f&quot;LLM: Intent={llm_intent.value}, Confidence={llm_confidence:.2f} (selected)&quot;)&#10;                return llm_intent, llm_confidence, llm_entities&#10;            else:&#10;                print(f&quot;LLM: Intent={llm_intent.value}, Confidence={llm_confidence:.2f} (rule-based kept)&quot;)&#10;&#10;        return intent, confidence, entities&#10;&#10;    def _rule_based_classify(self, normalized_input: str, context: Optional[Dict]) -&gt; Tuple[Intent, float, Dict]:&#10;        &quot;&quot;&quot;&#10;        Perform rule-based classification using regex patterns&#10;&#10;        Args:&#10;            normalized_input (str): Normalized user input&#10;            context (dict, optional): Session context&#10;&#10;        Returns:&#10;            Tuple of (Intent, confidence_score, extracted_entities)&#10;        &quot;&quot;&quot;&#10;        best_match = (Intent.UNKNOWN, 0.0, {})&#10;&#10;        # Check each intent's patterns&#10;        for intent, patterns in self.intent_patterns.items():&#10;            for pattern_dict in patterns:&#10;                pattern = pattern_dict[&quot;pattern&quot;]&#10;                base_confidence = pattern_dict[&quot;confidence&quot;]&#10;&#10;                match = re.search(pattern, normalized_input, re.IGNORECASE)&#10;                if match:&#10;                    # Extract entities based on intent type&#10;                    entities = self._extract_entities(intent, match, normalized_input)&#10;&#10;                    # Apply context boosting&#10;                    adjusted_confidence = self._apply_context_boost(&#10;                        intent, base_confidence, context, entities&#10;                    )&#10;&#10;                    # Keep best match&#10;                    if adjusted_confidence &gt; best_match[1]:&#10;                        best_match = (intent, adjusted_confidence, entities)&#10;&#10;        return best_match&#10;&#10;    def _extract_entities(self, intent: Intent, match: re.Match, text: str) -&gt; Dict:&#10;        &quot;&quot;&quot;&#10;        Extract relevant entities based on intent type&#10;&#10;        Args:&#10;            intent (Intent): Detected intent&#10;            match (re.Match): Regex match object&#10;            text (str): Full input text&#10;&#10;        Returns:&#10;            Dictionary of extracted entities&#10;        &quot;&quot;&quot;&#10;        entities = {}&#10;&#10;        # Extract step numbers for navigation&#10;        if intent in [Intent.NAV_GO_TO]:&#10;            step_match = re.search(r'\b(\d+)\b', text)&#10;            if step_match:&#10;                entities[&quot;step_number&quot;] = int(step_match.group(1))&#10;            elif &quot;first&quot; in text or &quot;beginning&quot; in text or &quot;start&quot; in text:&#10;                entities[&quot;step_number&quot;] = 1&#10;                entities[&quot;position&quot;] = &quot;first&quot;&#10;            elif &quot;last&quot; in text or &quot;end&quot; in text:&#10;                entities[&quot;position&quot;] = &quot;last&quot;&#10;&#10;        # Extract recipe name for search&#10;        if intent == Intent.SEARCH_RECIPE:&#10;            # Try to extract recipe name after trigger words&#10;            recipe_patterns = [&#10;                r'(?:recipe for|make|cook|prepare|find|search for|show me)\s+(?:a |an |the |some )?(.+?)(?:\?|$)',&#10;                r'(?:how to make|how to cook|how to prepare)\s+(?:a |an |the |some )?(.+?)(?:\?|$)',&#10;            ]&#10;            for pattern in recipe_patterns:&#10;                recipe_match = re.search(pattern, text, re.IGNORECASE)&#10;                if recipe_match:&#10;                    entities[&quot;recipe_name&quot;] = recipe_match.group(1).strip()&#10;                    break&#10;&#10;        # Extract question content&#10;        if intent == Intent.QUESTION:&#10;            entities[&quot;question_text&quot;] = text&#10;            # Identify question type&#10;            if re.search(r'\b(substitute|replace|instead of|alternative)\b', text):&#10;                entities[&quot;question_type&quot;] = &quot;substitution&quot;&#10;            elif re.search(r'\b(how long|how much time|duration)\b', text):&#10;                entities[&quot;question_type&quot;] = &quot;timing&quot;&#10;            elif re.search(r'\b(how much|how many|quantity)\b', text):&#10;                entities[&quot;question_type&quot;] = &quot;quantity&quot;&#10;            elif re.search(r'\b(what temperature|how hot)\b', text):&#10;                entities[&quot;question_type&quot;] = &quot;temperature&quot;&#10;            else:&#10;                entities[&quot;question_type&quot;] = &quot;general&quot;&#10;&#10;        return entities&#10;&#10;    def _apply_context_boost(self, intent: Intent, base_confidence: float,&#10;                            context: Optional[Dict], entities: Dict) -&gt; float:&#10;        &quot;&quot;&quot;&#10;        Adjust confidence based on session context&#10;&#10;        Args:&#10;            intent (Intent): Detected intent&#10;            base_confidence (float): Base confidence from pattern matching&#10;            context (dict, optional): Session context&#10;            entities (dict): Extracted entities&#10;&#10;        Returns:&#10;            Adjusted confidence score&#10;        &quot;&quot;&quot;&#10;        if not context:&#10;            return base_confidence&#10;&#10;        confidence = base_confidence&#10;        current_state = context.get(&quot;current_state&quot;, &quot;IDLE&quot;)&#10;&#10;        # Boost navigation intents when in active recipe&#10;        if intent in [Intent.NAV_NEXT, Intent.NAV_PREV, Intent.NAV_REPEAT, Intent.NAV_GO_TO]:&#10;            if current_state in [&quot;READING_INGREDIENTS&quot;, &quot;READING_STEPS&quot;, &quot;RECIPE_ACTIVE&quot;]:&#10;                confidence = min(1.0, confidence + 0.1)&#10;&#10;        # Boost START_RECIPE when recipe is selected&#10;        if intent == Intent.START_RECIPE:&#10;            if current_state == &quot;RECIPE_SELECTED&quot;:&#10;                confidence = min(1.0, confidence + 0.15)&#10;&#10;        # Boost RESUME when paused&#10;        if intent == Intent.RESUME:&#10;            if context.get(&quot;paused&quot;) == &quot;true&quot; or current_state == &quot;PAUSED&quot;:&#10;                confidence = min(1.0, confidence + 0.15)&#10;&#10;        # Boost QUESTION when in active recipe&#10;        if intent == Intent.QUESTION:&#10;            if current_state in [&quot;READING_INGREDIENTS&quot;, &quot;READING_STEPS&quot;, &quot;RECIPE_ACTIVE&quot;]:&#10;                confidence = min(1.0, confidence + 0.05)&#10;&#10;        return confidence&#10;&#10;    def _llm_classify(self, user_input: str, context: Optional[Dict]) -&gt; Tuple[Intent, float, Dict]:&#10;        &quot;&quot;&quot;&#10;        Use LLM to classify ambiguous intents&#10;&#10;        Args:&#10;            user_input (str): The user's input&#10;            context (dict, optional): Session context&#10;&#10;        Returns:&#10;            Tuple of (Intent, confidence_score, extracted_entities)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Build context string&#10;            context_str = &quot;&quot;&#10;            if context:&#10;                context_str = f&quot;&quot;&quot;&#10;Current Session Context:&#10;- State: {context.get('current_state', 'IDLE')}&#10;- Recipe Active: {context.get('recipe_id', 'None')}&#10;- Current Section: {context.get('current_section', 'None')}&#10;- Paused: {context.get('paused', 'false')}&#10;&quot;&quot;&quot;&#10;&#10;            # Create prompt for LLM&#10;            prompt = f&quot;&quot;&quot;You are an intent classifier for a conversational recipe voice assistant. &#10;Classify the user's input into ONE of the following intents:&#10;&#10;Available Intents:&#10;- nav_next: User wants to go to the next step/ingredient&#10;- nav_prev: User wants to go back to previous step/ingredient&#10;- nav_go_to: User wants to jump to a specific step/ingredient&#10;- nav_repeat: User wants to hear the current step again&#10;- nav_start: User wants to start from the beginning&#10;- question: User is asking a question about the recipe&#10;- search_recipe: User wants to find/search for a recipe&#10;- start_recipe: User wants to start cooking a selected recipe&#10;- stop_pause: User wants to pause or stop&#10;- resume: User wants to resume after pausing&#10;- confirm: User is confirming/agreeing (yes, okay, etc.)&#10;- cancel: User is canceling/disagreeing (no, cancel, etc.)&#10;- small_talk: Greetings or casual conversation or weather info &#10;- clarify: User needs clarification&#10;- help: User needs help or instructions&#10;- unknown: Cannot determine intent&#10;&#10;{context_str}&#10;&#10;User Input: &quot;{user_input}&quot;&#10;&#10;Respond in JSON format:&#10;{{&#10;    &quot;intent&quot;: &quot;intent_name&quot;,&#10;    &quot;confidence&quot;: 0.0-1.0,&#10;    &quot;reasoning&quot;: &quot;brief explanation&quot;,&#10;    &quot;entities&quot;: {{}}&#10;}}&#10;&#10;Extract relevant entities (e.g., step numbers, recipe names, question text) in the entities field.&#10;&quot;&quot;&quot;&#10;&#10;            # Call Gemini API&#10;            response = self.client.models.generate_content(&#10;                model=self.model_name,&#10;                contents=prompt&#10;            )&#10;&#10;            # Parse response&#10;            response_text = response.text.strip()&#10;            print(f&quot;LLM Response: {response_text}&quot;)&#10;&#10;            # Extract JSON from response (handle markdown code blocks)&#10;            if &quot;```json&quot; in response_text:&#10;                json_start = response_text.find(&quot;```json&quot;) + 7&#10;                json_end = response_text.find(&quot;```&quot;, json_start)&#10;                response_text = response_text[json_start:json_end].strip()&#10;            elif &quot;```&quot; in response_text:&#10;                json_start = response_text.find(&quot;```&quot;) + 3&#10;                json_end = response_text.find(&quot;```&quot;, json_start)&#10;                response_text = response_text[json_start:json_end].strip()&#10;&#10;            import json&#10;            result = json.loads(response_text)&#10;&#10;            # Map string intent to Intent enum&#10;            intent_str = result.get(&quot;intent&quot;, &quot;unknown&quot;)&#10;            try:&#10;                intent = Intent(intent_str)&#10;            except ValueError:&#10;                intent = Intent.UNKNOWN&#10;&#10;            confidence = float(result.get(&quot;confidence&quot;, 0.5))&#10;            entities = result.get(&quot;entities&quot;, {})&#10;&#10;            return intent, confidence, entities&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error in LLM classification: {str(e)}&quot;)&#10;            return Intent.UNKNOWN, 0.3, {}&#10;&#10;    def get_intent_description(self, intent: Intent) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Get human-readable description of an intent&#10;&#10;        Args:&#10;            intent (Intent): The intent to describe&#10;&#10;        Returns:&#10;            Description string&#10;        &quot;&quot;&quot;&#10;        descriptions = {&#10;            Intent.NAV_NEXT: &quot;Navigate to next step/ingredient&quot;,&#10;            Intent.NAV_PREV: &quot;Navigate to previous step/ingredient&quot;,&#10;            Intent.NAV_GO_TO: &quot;Jump to specific step/ingredient&quot;,&#10;            Intent.NAV_REPEAT: &quot;Repeat current step&quot;,&#10;            Intent.NAV_START: &quot;Start from beginning&quot;,&#10;            Intent.QUESTION: &quot;Ask a question about the recipe&quot;,&#10;            Intent.SEARCH_RECIPE: &quot;Search for a recipe&quot;,&#10;            Intent.START_RECIPE: &quot;Begin cooking selected recipe&quot;,&#10;            Intent.STOP_PAUSE: &quot;Pause or stop&quot;,&#10;            Intent.RESUME: &quot;Resume from pause&quot;,&#10;            Intent.CONFIRM: &quot;Confirm/agree&quot;,&#10;            Intent.CANCEL: &quot;Cancel/disagree&quot;,&#10;            Intent.SMALL_TALK: &quot;Casual conversation&quot;,&#10;            Intent.CLARIFY: &quot;Request clarification&quot;,&#10;            Intent.HELP: &quot;Request help&quot;,&#10;            Intent.UNKNOWN: &quot;Cannot determine intent&quot;&#10;        }&#10;        return descriptions.get(intent, &quot;Unknown intent&quot;)&#10;&#10;&#10;# Test function&#10;def test_intent_classifier():&#10;    &quot;&quot;&quot;Test the intent classifier with sample inputs&quot;&quot;&quot;&#10;    classifier = IntentClassifier(confidence_threshold=0.7, use_llm_fallback=True)&#10;&#10;    test_cases = [&#10;        (&quot;next step please&quot;, None),&#10;        (&quot;go back&quot;, None),&#10;        (&quot;what's the third step?&quot;, {&quot;current_state&quot;: &quot;RECIPE_ACTIVE&quot;}),&#10;        (&quot;repeat that&quot;, {&quot;current_state&quot;: &quot;READING_STEPS&quot;}),&#10;        (&quot;how do I make pasta?&quot;, None),&#10;        (&quot;start cooking&quot;, {&quot;current_state&quot;: &quot;RECIPE_SELECTED&quot;}),&#10;        (&quot;pause&quot;, None),&#10;        (&quot;can I use butter instead of oil?&quot;, {&quot;current_state&quot;: &quot;RECIPE_ACTIVE&quot;}),&#10;        (&quot;yes&quot;, None),&#10;        (&quot;what is weather today&quot;, None),&#10;        (&quot;Can u repeat the recipe from starting?&quot;, None),&#10;        (&quot;well how are u doing today?&quot;, None),&#10;        (&quot;find me a recipe for chocolate cake&quot;, None),&#10;        (&quot;let's start cooking this recipe&quot;, {&quot;current_state&quot;: &quot;RECIPE_SELECTED&quot;}),&#10;        (&quot;resume where we left off&quot;, {&quot;current_state&quot;: &quot;PAUSED&quot;}),&#10;        (&quot;no, I don't want that&quot;, None),&#10;        (&quot;help me with the commands&quot;, None),&#10;        (&quot;&quot;, None),&#10;        (&quot;   &quot;, None),&#10;        (&quot;blablabla unknown input&quot;, None),&#10;        (&quot;how to make a vegan salad?&quot;, None),&#10;    ]&#10;&#10;    print(&quot;=&quot; * 60)&#10;    print(&quot;INTENT CLASSIFIER TEST&quot;)&#10;    print(&quot;=&quot; * 60)&#10;&#10;    for user_input, context in test_cases:&#10;        print(f&quot;\nInput: '{user_input}'&quot;)&#10;        if context:&#10;            print(f&quot;Context: {context}&quot;)&#10;&#10;        intent, confidence, entities = classifier.classify(user_input, context)&#10;&#10;        print(f&quot;→ Intent: {intent.value}&quot;)&#10;        print(f&quot;→ Confidence: {confidence:.2f}&quot;)&#10;        print(f&quot;→ Description: {classifier.get_intent_description(intent)}&quot;)&#10;        if entities:&#10;            print(f&quot;→ Entities: {entities}&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    test_intent_classifier()&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>